Index: AbyssPointsService.java
===================================================================
--- AbyssPointsService.java	(nonexistent)
+++ AbyssPointsService.java	(working copy)
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+package com.aionemu.gameserver.services.abyss;
+
+import com.aionemu.commons.callbacks.Callback;
+import com.aionemu.commons.callbacks.CallbackResult;
+import com.aionemu.commons.callbacks.metadata.GlobalCallback;
+import com.aionemu.gameserver.model.gameobjects.VisibleObject;
+import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.model.gameobjects.siege.SiegeNpc;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_ABYSS_RANK;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_ABYSS_RANK_UPDATE;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_LEGION_EDIT;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_SYSTEM_MESSAGE;
+import com.aionemu.gameserver.utils.PacketSendUtility;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+import com.aionemu.gameserver.world.World;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * @author ATracer
+ */
+public class AbyssPointsService {
+
+	private static final Logger log = LoggerFactory.getLogger(AbyssPointsService.class);
+    private static final Logger debuglog = LoggerFactory.getLogger("ABYSSRANK_LOG");
+
+    @GlobalCallback(AddAPGlobalCallback.class)
+    public static void addAGp(Player player, VisibleObject obj, int ap, int gp)
+    {
+        if ((ap > 30000) || (gp > 30000)) {
+            log.warn("WARN BIG COUNT AP: " + ap + " GP:" + gp + " name: " + obj.getName() + " obj: " + obj.getObjectId() + " player: " + player.getObjectId());
+        }
+        addAGp(player, ap, gp);
+    }
+
+    public static void addAp(Player player, int ap){
+        addAGp(player, ap, 0);
+    }
+
+    public static void addAp(Player player, VisibleObject obj, int ap){
+        addAGp(player, obj, ap, 0);
+    }
+
+    public static void addAGp(Player player, int ap, int gp)
+    {
+        if (player == null) {
+            return;
+        }
+        // ranking SO
+        if (player.getAbyssRank().getRank().getId() < AbyssRankEnum.GRADE1_SOLDIER.getId()) {
+            gp = 0;
+        }
+        if ((gp != 0) && (gp > 0)) {
+            PacketSendUtility.sendPacket(player, SM_SYSTEM_MESSAGE.STR_MSG_GLORY_POINT_GAIN(gp));
+        } else if (gp < 0) {
+            PacketSendUtility.sendPacket(player, SM_SYSTEM_MESSAGE.STR_MSG_GLORY_POINT_LOSE(gp * -1));
+        }
+        if ((ap != 0) && (ap > 0)) {
+            PacketSendUtility.sendPacket(player, SM_SYSTEM_MESSAGE.STR_MSG_COMBAT_MY_ABYSS_POINT_GAIN(ap));
+        }
+        setAGp(player, ap, gp);
+        if ((player.isLegionMember()) && (ap > 0))
+        {
+            player.getLegion().addContributionPoints(ap);
+            PacketSendUtility.broadcastPacketToLegion(player.getLegion(), new SM_LEGION_EDIT(3, player.getLegion()));
+        }
+        if ((player.isLegionMember()) && (gp > 0))
+        {
+            player.getLegion().addContributionPoints(gp);
+            PacketSendUtility.broadcastPacketToLegion(player.getLegion(), new SM_LEGION_EDIT(3, player.getLegion()));
+        }
+    }
+
+    public static void setAGp(Player player, int ap, int gp)
+    {
+        if (player == null) {
+            return;
+        }
+        AbyssRank rank = player.getAbyssRank();
+        if (gp != 0)
+            debuglog.info("[GP REWARD LOG] Player: " + player.getName() + ". Have GP before: " + player.getAbyssRank().getGp() + ". Reward: " + gp);
+        AbyssRankEnum oldAbyssRank = rank.getRank();
+        if ((ap != 0) || (gp != 0)) {
+            rank.addAGp(ap, gp);
+        }
+        AbyssRankEnum newAbyssRank = rank.getRank();
+
+        checkRankChanged(player, oldAbyssRank, newAbyssRank);
+
+        PacketSendUtility.sendPacket(player, new SM_ABYSS_RANK(player.getAbyssRank()));
+    }
+
+    public static void checkRankChanged(Player player, AbyssRankEnum oldAbyssRank, AbyssRankEnum newAbyssRank)
+    {
+        if (oldAbyssRank == newAbyssRank) {
+            return;
+        }
+        PacketSendUtility.broadcastPacketAndReceive(player, new SM_ABYSS_RANK_UPDATE(0, player));
+
+        player.getEquipment().checkRankLimitItems();
+        AbyssSkillService.updateSkills(player);
+    }
+
+    public static abstract class AddAPGlobalCallback implements Callback
+    {
+        public CallbackResult beforeCall(Object obj, Object[] args)
+        {
+            return CallbackResult.newContinue();
+        }
+
+        public CallbackResult afterCall(Object obj, Object[] args, Object methodResult)
+        {
+            Player player = (Player)args[0];
+            VisibleObject creature = (VisibleObject)args[1];
+            int abyssPoints = (Integer)args[2];
+
+            if ((creature instanceof Player)) {
+                onAbyssPointsAdded(player, abyssPoints);
+            } else if (((creature instanceof SiegeNpc)) && (!((SiegeNpc)creature).getSpawn().isPeace())) {
+                onAbyssPointsAdded(player, abyssPoints);
+            }
+
+            return CallbackResult.newContinue();
+        }
+
+        public Class<? extends Callback> getBaseClass()
+        {
+            return AddAPGlobalCallback.class;
+        }
+
+        public abstract void onAbyssPointsAdded(Player paramPlayer, int paramInt);
+    }
+}
Index: AbyssRank.java
===================================================================
--- AbyssRank.java	(nonexistent)
+++ AbyssRank.java	(working copy)
@@ -0,0 +1,293 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.model.gameobjects.player;
+
+import java.util.Calendar;
+
+import com.aionemu.gameserver.configs.main.CustomConfig;
+import com.aionemu.gameserver.model.gameobjects.PersistentState;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+
+/**
+ * @author ATracer, Divinity
+ */
+public class AbyssRank {
+
+    private int dailyAP;
+    private int dailyGP;
+    private int weeklyAP;
+    private int weeklyGP;
+    private int currentAp;
+    private int currentGP;
+    private AbyssRankEnum rank;
+    private int topRanking;
+    private PersistentState persistentState;
+    private int dailyKill;
+    private int weeklyKill;
+    private int allKill;
+    private int maxRank;
+    private int lastKill;
+    private int lastAP;
+    private int lastGP;
+    private long lastUpdate;
+
+    public AbyssRank(int dailyAP, int dailyGP, int weeklyAP, int weeklyGP, int ap, int gp, int rank, int topRanking, int dailyKill,
+                     int weeklyKill, int allKill, int maxRank, int lastKill, int lastAP, int lastGP, long lastUpdate) {
+        this.dailyAP = dailyAP;
+        this.dailyGP = dailyGP;
+        this.weeklyAP = weeklyAP;
+        this.weeklyGP = weeklyGP;
+        this.currentAp = ap;
+        this.currentGP = gp;
+        this.rank = AbyssRankEnum.getRankById(rank);
+        this.topRanking = topRanking;
+        this.dailyKill = dailyKill;
+        this.weeklyKill = weeklyKill;
+        this.allKill = allKill;
+        this.maxRank = maxRank;
+        this.lastKill = lastKill;
+        this.lastAP = lastAP;
+        this.lastGP = lastGP;
+        this.lastUpdate = lastUpdate;
+
+        doUpdate();
+	}
+
+	public enum AbyssRankUpdateType{
+		PLAYER_ELYOS (1),
+		PLAYER_ASMODIANS(2),
+		LEGION_ELYOS(4),
+		LEGION_ASMODIANS(8);
+
+		private int id;
+		AbyssRankUpdateType(int id){
+			this.id = id;
+		}
+
+		public int value() {
+			return id;
+		}
+	}
+
+    public void addAGp(int additionalAp, int additionalGp)
+    {
+        this.dailyAP += additionalAp;
+        this.dailyGP += additionalGp;
+        if (this.dailyAP < 0) {
+            this.dailyAP = 0;
+        }
+
+        if (this.dailyGP < 0) {
+            this.dailyGP = 0;
+        }
+        this.weeklyAP += additionalAp;
+        this.weeklyGP += additionalGp;
+        if (this.weeklyAP < 0) {
+            this.weeklyAP = 0;
+        }
+
+        if (this.weeklyGP < 0) {
+            this.weeklyGP = 0;
+        }
+
+        int cappedCount = 0;
+        if (CustomConfig.ENABLE_AP_CAP) {
+            cappedCount = this.currentAp + additionalAp > CustomConfig.AP_CAP_VALUE ? (int)(CustomConfig.AP_CAP_VALUE - this.currentAp) : additionalAp;
+        } else {
+            cappedCount = additionalAp;
+        }
+        this.currentAp += cappedCount;
+        this.currentGP += additionalGp;
+        if (this.currentAp < 0) {
+            this.currentAp = 0;
+        }
+
+        if (this.currentGP < 0) {
+            this.currentGP = 0;
+        }
+
+        AbyssRankEnum newRank = AbyssRankEnum.getRankForAGp(this.currentAp, this.currentGP);
+        if (newRank.getId() <= 9)
+            setRank(newRank);
+
+        setPersistentState(PersistentState.UPDATE_REQUIRED);
+    }
+
+    public int getDailyAP()
+    {
+      return dailyAP;
+    }
+
+    public int getDailyGP()
+    {
+      return dailyGP;
+    }
+
+    public int getWeeklyAP()
+    {
+      return weeklyAP;
+    }
+
+    public int getWeeklyGP()
+    {
+      return weeklyGP;
+    }
+
+    public int getAp()
+    {
+      return currentAp;
+    }
+
+    public int getGp()
+    {
+      return currentGP;
+    }
+
+    public AbyssRankEnum getRank()
+    {
+      return rank;
+    }
+
+    public int getTopRanking()
+    {
+      return topRanking;
+    }
+
+    public void setTopRanking(int topRanking)
+    {
+      this.topRanking = topRanking;
+    }
+
+    public int getDailyKill()
+    {
+      return dailyKill;
+    }
+
+    public int getWeeklyKill()
+    {
+      return weeklyKill;
+    }
+
+    public int getAllKill()
+    {
+      return allKill;
+    }
+
+    public void setAllKill()
+    {
+      dailyKill += 1;
+      weeklyKill += 1;
+      allKill += 1;
+    }
+
+    public int getMaxRank() { return maxRank; }
+
+    public int getLastKill()
+    {
+      return lastKill;
+    }
+
+    public int getLastAP()
+    {
+      return lastAP;
+    }
+
+    public int getLastGP()
+    {
+      return lastGP;
+    }
+
+    public void setRank(AbyssRankEnum rank)
+    {
+        if (rank.getId() > maxRank) {
+            maxRank = rank.getId();
+        }
+        this.rank = rank;
+
+
+        topRanking = rank.getQuota();
+        setPersistentState(PersistentState.UPDATE_REQUIRED);
+    }
+
+    public PersistentState getPersistentState()
+    {
+        return persistentState;
+    }
+
+    public void setPersistentState(PersistentState persistentState)
+    {
+        if ((persistentState != PersistentState.UPDATE_REQUIRED) || (this.persistentState != PersistentState.NEW)) {
+          this.persistentState = persistentState;
+        }
+    }
+
+    public long getLastUpdate()
+    {
+        return lastUpdate;
+    }
+
+    public void doUpdate()
+    {
+        boolean needUpdate = false;
+        Calendar lastCal = Calendar.getInstance();
+        lastCal.setTimeInMillis(lastUpdate);
+
+        Calendar curCal = Calendar.getInstance();
+        curCal.setTimeInMillis(System.currentTimeMillis());
+        if ((lastCal.get(Calendar.DATE) != curCal.get(Calendar.DATE)) || (lastCal.get(Calendar.MONTH) != curCal.get(Calendar.MONTH)) || (lastCal.get(Calendar.YEAR) != curCal.get(Calendar.YEAR)))
+        {
+            this.dailyAP = 0;
+            this.dailyGP = 0;
+            this.dailyKill = 0;
+            needUpdate = true;
+        }
+        if ((lastCal.get(Calendar.WEEK_OF_YEAR) != curCal.get(Calendar.WEEK_OF_YEAR)) || (lastCal.get(Calendar.YEAR) != curCal.get(Calendar.YEAR)))
+        {
+            this.lastKill = this.weeklyKill;
+            this.lastAP = this.weeklyAP;
+            this.lastGP = this.weeklyGP;
+            this.weeklyKill = 0;
+            this.weeklyAP = 0;
+            this.weeklyGP = 0;
+            needUpdate = true;
+        }
+        if (this.rank.getId() > this.maxRank)
+        {
+            this.maxRank = this.rank.getId();
+            needUpdate = true;
+        }
+        this.lastUpdate = System.currentTimeMillis();
+        if (needUpdate) {
+            setPersistentState(PersistentState.UPDATE_REQUIRED);
+        }
+    }
+}
Index: AbyssRankDAO.java
===================================================================
--- AbyssRankDAO.java	(nonexistent)
+++ AbyssRankDAO.java	(working copy)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.dao;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import com.aionemu.commons.database.dao.DAO;
+import com.aionemu.gameserver.model.AbyssRankingResult;
+import com.aionemu.gameserver.model.Race;
+import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.services.abyss.AGPoint;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+
+/**
+ * @author ATracer
+ */
+public abstract class AbyssRankDAO implements DAO {
+
+	@Override
+	public final String getClassName() {
+		return AbyssRankDAO.class.getName();
+	}
+
+    public abstract List<Integer> RankPlayers(final int rank);
+
+    public abstract void updataGloryPoint(final int playerId, final int gp);
+
+	public abstract void loadAbyssRank(Player player);
+
+	public abstract AbyssRank loadAbyssRank(int playerId);
+
+	public abstract boolean storeAbyssRank(Player player);
+
+	public abstract ArrayList<AbyssRankingResult> getAbyssRankingPlayers(final Race race, final int lowerApLimit, final int maxOfflineDays);
+
+	public abstract ArrayList<AbyssRankingResult> getAbyssRankingLegions(Race race);
+
+    public abstract void loadPlayersAp(final Race race, final int lowerApLimit, final int maxOfflineDays, final Map<Integer, AGPoint> results);
+
+    public abstract void loadPlayersGp(final Race race, final int lowerApLimit, final int maxOfflineDays, final Map<Integer, AGPoint> results); // 4.5.2
+
+	public abstract void updateAbyssRank(int playerId, AbyssRankEnum rankEnum);
+
+	public abstract void updateRankList(final int maxOfflineDays);
+}
Index: AbyssRankEnum.java
===================================================================
--- AbyssRankEnum.java	(nonexistent)
+++ AbyssRankEnum.java	(working copy)
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.utils.stats;
+
+import com.aionemu.gameserver.configs.main.RateConfig;
+import com.aionemu.gameserver.model.DescriptionId;
+import com.aionemu.gameserver.model.Race;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+
+import javax.xml.bind.annotation.XmlEnum;
+
+/**
+ * @author ATracer
+ * @author Sarynth
+ * @author Imaginary
+ */
+@XmlEnum
+public enum AbyssRankEnum {
+
+    GRADE9_SOLDIER(1, 120, 24, 0, 0, 0, 0, 1802431),
+    GRADE8_SOLDIER(2, 168, 37, 1200, 0, 0, 0, 1802433),
+    GRADE7_SOLDIER(3, 235, 58, 4220, 0, 0, 0, 1802435),
+    GRADE6_SOLDIER(4, 329, 91, 10990, 0, 0, 0, 1802437),
+    GRADE5_SOLDIER(5, 461, 143, 23500, 0, 0, 0, 1802439),
+    GRADE4_SOLDIER(6, 645, 225, 42780, 0, 0, 0, 1802441),
+    GRADE3_SOLDIER(7, 903, 356, 69700, 0, 0, 0, 1802443),
+    GRADE2_SOLDIER(8, 1264, 561, 105600, 0, 0, 0, 1802445),
+    GRADE1_SOLDIER(9, 1770, 885, 150800, 0, 0, 0, 1802447),
+    STAR1_OFFICER(10, 2124, 1428, 0, 1244, 7, 1000, 1802449),
+    STAR2_OFFICER(11, 2549, 1973, 0, 1368, 14, 700, 1802451),
+    STAR3_OFFICER(12, 3059, 2704, 0, 1915, 28, 500, 1802453),
+    STAR4_OFFICER(13, 3671, 3683, 0, 3064, 49, 300, 1802455),
+    STAR5_OFFICER(14, 4405, 4994, 0, 5210, 107, 100, 1802457),
+    GENERAL(15, 5286, 6749, 0, 8335, 119, 30, 1802459),
+    GREAT_GENERAL(16, 6343, 9098, 0, 10002, 122, 10, 1802461),
+    COMMANDER(17, 7612, 11418, 0, 11503, 127, 3, 1802463),
+    SUPREME_COMMANDER(18, 9134, 13701, 0, 12437, 147, 1, 1802465);
+
+    private int id;
+    private int pointsGained;
+    private int pointsLost;
+    private int requiredAP;
+    private int requiredGP;
+    private int delgp;
+    private int quota;
+    private int descriptionId;
+
+    private AbyssRankEnum(int id, int pointsGained, int pointsLost, int requiredAP, int requiredGP, int delgp, int quota, int descriptionId) {
+        this.id = id;
+        this.pointsGained = pointsGained;
+        this.pointsLost = pointsLost;
+        this.requiredAP = (requiredAP * RateConfig.ABYSS_RANK_RATE);
+        this.requiredGP = requiredGP;
+        this.delgp = delgp;
+        this.quota = quota;
+        this.descriptionId = descriptionId;
+	}
+
+	/**
+	 * @return the id
+	 */
+	public int getId() {
+		return id;
+	}
+
+	/**
+	 * @return the pointsLost
+	 */
+	public int getPointsLost() {
+		return pointsLost;
+	}
+
+	/**
+	 * @return the pointsGained
+	 */
+	public int getPointsGained() {
+		return pointsGained;
+	}
+
+	/**
+	 * @return AP required for Rank
+	 */
+	public int getAPRequired() {
+		return requiredAP;
+	}
+
+	/**
+     * @return Glory Point required for Rank
+     */
+    public int getGPRequired() {
+        return requiredGP;
+    }
+
+    public int getDelGp()
+    {
+        return this.delgp;
+    }
+
+	/**
+	 * @return The quota is the maximum number of allowed player to have the rank
+	 */
+	public int getQuota() {
+		return quota;
+	}
+
+	public int getDescriptionId() {
+		return descriptionId;
+	}
+
+	public static DescriptionId getRankDescriptionId(Player player){
+		int pRankId = player.getAbyssRank().getRank().getId();
+		for (AbyssRankEnum rank : values()) {
+			if (rank.getId() == pRankId) {
+				int descId = rank.getDescriptionId();
+				return (player.getRace() == Race.ELYOS) ? new DescriptionId(descId) : new DescriptionId(descId + 36);
+			}
+		}
+		throw new IllegalArgumentException("No rank Description Id found for player: " + player);
+	}
+
+	/**
+	 * @param id
+	 * @return The abyss rank enum by his id
+	 */
+	public static AbyssRankEnum getRankById(int id) {
+		for (AbyssRankEnum rank : values()) {
+			if (rank.getId() == id)
+				return rank;
+		}
+		throw new IllegalArgumentException("Invalid abyss rank provided" + id);
+	}
+
+    public static AbyssRankEnum getRankForAGp(int ap, int gp)
+    {
+        AbyssRankEnum r = GRADE9_SOLDIER;
+        for (AbyssRankEnum rank : values()) {
+            if (gp >= 1244 && ap >= 150800)
+            {
+                if (rank.getGPRequired() > gp) {
+                    break;
+                }
+                r = rank;
+            } else {
+                if ((rank.getAPRequired() > ap) || (rank.id > 9)) {
+                    break;
+                }
+                r = rank;
+            }
+        }
+        return r;
+    }
+}
Index: AbyssRankingCache.java
===================================================================
--- AbyssRankingCache.java	(nonexistent)
+++ AbyssRankingCache.java	(working copy)
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.services.abyss;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+import javolution.util.FastMap;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.aionemu.commons.database.dao.DAOManager;
+import com.aionemu.gameserver.configs.main.RankingConfig;
+import com.aionemu.gameserver.dao.AbyssRankDAO;
+import com.aionemu.gameserver.model.AbyssRankingResult;
+import com.aionemu.gameserver.model.Race;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_ABYSS_RANKING_LEGIONS;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_ABYSS_RANKING_PLAYERS;
+import com.aionemu.gameserver.services.LegionService;
+import com.aionemu.gameserver.world.World;
+import com.aionemu.gameserver.world.knownlist.Visitor;
+
+/**
+ * @author VladimirZ
+ */
+public class AbyssRankingCache {
+
+	private static final Logger log = LoggerFactory.getLogger(AbyssRankingCache.class);
+	private int lastUpdate;
+	private final FastMap<Race, List<SM_ABYSS_RANKING_PLAYERS>> players = new FastMap<Race, List<SM_ABYSS_RANKING_PLAYERS>>();
+	private final FastMap<Race, SM_ABYSS_RANKING_LEGIONS> legions = new FastMap<Race, SM_ABYSS_RANKING_LEGIONS>();
+
+	public void reloadRankings() {
+		log.info("Updating abyss ranking cache");
+		this.lastUpdate = (int) (System.currentTimeMillis() / 1000);
+		getDAO().updateRankList(RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS);
+
+		renewPlayerRanking(Race.ASMODIANS);
+		renewPlayerRanking(Race.ELYOS);
+
+		renewLegionRanking();
+
+		World.getInstance().doOnAllPlayers(new Visitor<Player>() {
+			@Override
+			public void visit(Player player) {
+				player.resetAbyssRankListUpdated();
+			}
+		});
+	}
+
+	/**
+	 * Renews the legion's rank and SM_ABYSS_RANKING_LEGIONS
+	 */
+	private void renewLegionRanking() {
+		Map<Integer, Integer> newLegionRankingCache = new HashMap<Integer, Integer>();
+		ArrayList<AbyssRankingResult> elyosRanking = getDAO().getAbyssRankingLegions(Race.ELYOS), asmoRanking = getDAO().getAbyssRankingLegions(Race.ASMODIANS);
+
+		legions.clear();
+		legions.put(Race.ASMODIANS, new SM_ABYSS_RANKING_LEGIONS(lastUpdate, asmoRanking, Race.ASMODIANS));
+		legions.put(Race.ELYOS, new SM_ABYSS_RANKING_LEGIONS(lastUpdate, elyosRanking, Race.ELYOS));
+
+		for (AbyssRankingResult result : elyosRanking) {
+			newLegionRankingCache.put(result.getLegionId(), result.getRankPos());
+		}
+		for (AbyssRankingResult result : asmoRanking) {
+			newLegionRankingCache.put(result.getLegionId(), result.getRankPos());
+		}
+
+		LegionService.getInstance().performRankingUpdate(newLegionRankingCache);
+	}
+
+	/**
+	 * Renews the player ranking by race
+	 *
+	 * @param race
+	 */
+	private void renewPlayerRanking(Race race) {
+		//delete not before new list is created
+		List<SM_ABYSS_RANKING_PLAYERS> newlyCalculated;
+		newlyCalculated = generatePacketsForRace(race);
+		players.remove(race);
+		players.put(race, newlyCalculated);
+	}
+
+    private List<SM_ABYSS_RANKING_PLAYERS> generatePacketsForRace(Race race)
+    {
+        ArrayList<AbyssRankingResult> list = getDAO().getAbyssRankingPlayers(race, AbyssRankEnum.STAR1_OFFICER.getGPRequired(), RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS);
+        int page = 1;
+        List<SM_ABYSS_RANKING_PLAYERS> playerPackets = new ArrayList();
+        for (int i = 0; i < list.size(); i += 44)
+        {
+            if (list.size() > i + 44) {
+                playerPackets.add(new SM_ABYSS_RANKING_PLAYERS(this.lastUpdate, list.subList(i, i + 44), race, page, false));
+            } else {
+                playerPackets.add(new SM_ABYSS_RANKING_PLAYERS(this.lastUpdate, list.subList(i, list.size()), race, page, true));
+            }
+            page++;
+        }
+        return playerPackets;
+    }
+
+	/**
+	 * @return all players
+	 */
+	public List<SM_ABYSS_RANKING_PLAYERS> getPlayers(Race race) {
+		return players.get(race);
+	}
+
+	/**
+	 * @return all legions
+	 */
+	public SM_ABYSS_RANKING_LEGIONS getLegions(Race race) {
+		return legions.get(race);
+	}
+
+	/**
+	 * @return the lastUpdate
+	 */
+	public int getLastUpdate() {
+		return lastUpdate;
+	}
+
+	private AbyssRankDAO getDAO() {
+		return DAOManager.getDAO(AbyssRankDAO.class);
+	}
+
+	public static final AbyssRankingCache getInstance() {
+		return SingletonHolder.INSTANCE;
+	}
+
+	private static class SingletonHolder {
+
+		protected static final AbyssRankingCache INSTANCE = new AbyssRankingCache();
+	}
+}
Index: AbyssRankUpdateService.java
===================================================================
--- AbyssRankUpdateService.java	(nonexistent)
+++ AbyssRankUpdateService.java	(working copy)
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.services.abyss;
+
+import com.aionemu.commons.database.dao.DAOManager;
+import com.aionemu.commons.services.CronService;
+import com.aionemu.gameserver.configs.main.RankingConfig;
+import com.aionemu.gameserver.dao.AbyssRankDAO;
+import com.aionemu.gameserver.dao.ServerVariablesDAO;
+import com.aionemu.gameserver.model.Race;
+import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_SYSTEM_MESSAGE;
+import com.aionemu.gameserver.utils.PacketSendUtility;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+import com.aionemu.gameserver.world.World;
+import com.aionemu.gameserver.world.knownlist.Visitor;
+import org.quartz.JobDetail;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * @author ATracer
+ */
+public class AbyssRankUpdateService {
+
+    private static final String GP_UPDATA_TIME = "0 10 5 ? * *";
+    private Map<Integer, AGPoint> playerAGpMaps = new HashMap();
+    private List<Map.Entry<Integer, AGPoint>> playerAGPEntries;
+
+	private static final Logger log = LoggerFactory.getLogger(AbyssRankUpdateService.class);
+    private static final Logger debuglog = LoggerFactory.getLogger("ABYSSRANK_LOG");
+
+	private AbyssRankUpdateService() {
+	}
+
+	public static AbyssRankUpdateService getInstance() {
+		return SingletonHolder.instance;
+	}
+
+    public void GpointUpdata()
+    {
+        CronService.getInstance().schedule(new Runnable()
+        {
+            public void run()
+            {
+                AbyssRankUpdateService.this.loadGpRank();
+            }
+        }, GP_UPDATA_TIME);
+    }
+
+    private void loadGpRank()
+    {
+        List<Integer> rankPlayers = DAOManager.getDAO(AbyssRankDAO.class).RankPlayers(9);
+        delGpoint(rankPlayers);
+    }
+
+    private void delGpoint(List<Integer> rankPlayers)
+    {
+        for (int playerId : rankPlayers)
+        {
+            AbyssRank rank = DAOManager.getDAO(AbyssRankDAO.class).loadAbyssRank(playerId);
+            Player player = World.getInstance().findPlayer(playerId);
+            int lostGp = rank.getRank().getDelGp();
+          
+            if (rank.getRank().getId() < AbyssRankEnum.STAR1_OFFICER.getId())
+                continue;
+            if (player != null)
+            {
+                PacketSendUtility.sendPacket(player, new SM_SYSTEM_MESSAGE(1402082, new Object[0]));
+                PacketSendUtility.sendPacket(player, SM_SYSTEM_MESSAGE.STR_MSG_GLORY_POINT_LOSE_PERSONAL(rank.getRank().getDelGp()));
+                AbyssPointsService.addAGp(player, 0, lostGp * -1);
+
+            }
+            else
+            {
+                int newGP = rank.getGp() - lostGp;
+                if (newGP < 0)
+                    newGP = 0;
+                debuglog.info("[GP REWARD LOG] Scheduled delete. Player: " + playerId + ". Last: " + rank.getGp() +". New: "+ newGP);
+                DAOManager.getDAO(AbyssRankDAO.class).updataGloryPoint(playerId, newGP);
+            }
+        }
+    }
+
+	public void scheduleUpdate() {
+		ServerVariablesDAO dao = DAOManager.getDAO(ServerVariablesDAO.class);
+		int nextTime = dao.load("abyssRankUpdate");
+		if (nextTime < System.currentTimeMillis()/1000){
+			performUpdate();
+		}
+
+		log.info("Starting ranking update task based on cron expression: " + RankingConfig.TOP_RANKING_UPDATE_RULE);
+		CronService.getInstance().schedule(new Runnable() {
+			@Override
+			public void run() {
+				performUpdate();
+			}
+		}, RankingConfig.TOP_RANKING_UPDATE_RULE, true);
+	}
+
+	/**
+	 * Perform update of all ranks
+	 */
+	public void performUpdate() {
+		log.info("AbyssRankUpdateService: executing rank update");
+		long startTime = System.currentTimeMillis();
+
+		World.getInstance().doOnAllPlayers(new Visitor<Player>() {
+
+			@Override
+			public void visit(Player player) {
+				player.getAbyssRank().doUpdate(); // 4.5.2
+				DAOManager.getDAO(AbyssRankDAO.class).storeAbyssRank(player);
+			}
+		});
+
+		updateLimitedRanks(); // 4.5.2
+		AbyssRankingCache.getInstance().reloadRankings();
+		log.info("AbyssRankUpdateService: execution time: " + (System.currentTimeMillis() - startTime) / 1000);
+	}
+
+	/**
+	 * Update player ranks based on quota for all players (online/offline)
+	 */
+	private void updateLimitedRanks() {
+        DAOManager.getDAO(AbyssRankDAO.class).loadPlayersGp(Race.ASMODIANS, AbyssRankEnum.STAR1_OFFICER.getGPRequired(), RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS, this.playerAGpMaps);
+        DAOManager.getDAO(AbyssRankDAO.class).loadPlayersAp(Race.ASMODIANS, AbyssRankEnum.GRADE8_SOLDIER.getAPRequired(), RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS, this.playerAGpMaps);
+        updateAllRanksForRace();
+        DAOManager.getDAO(AbyssRankDAO.class).loadPlayersGp(Race.ELYOS, AbyssRankEnum.STAR1_OFFICER.getGPRequired(), RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS, this.playerAGpMaps);
+        DAOManager.getDAO(AbyssRankDAO.class).loadPlayersAp(Race.ELYOS, AbyssRankEnum.GRADE8_SOLDIER.getAPRequired(), RankingConfig.TOP_RANKING_MAX_OFFLINE_DAYS, this.playerAGpMaps);
+        updateAllRanksForRace();
+	}
+
+    private void updateAllRanksForRace()
+    {
+        this.playerAGPEntries = new ArrayList(this.playerAGpMaps.entrySet());
+        Collections.sort(this.playerAGPEntries, new PlayerGpComparator());
+        selectRank(AbyssRankEnum.SUPREME_COMMANDER);
+        selectRank(AbyssRankEnum.COMMANDER);
+        selectRank(AbyssRankEnum.GREAT_GENERAL);
+        selectRank(AbyssRankEnum.GENERAL);
+        selectRank(AbyssRankEnum.STAR5_OFFICER);
+        selectRank(AbyssRankEnum.STAR4_OFFICER);
+        selectRank(AbyssRankEnum.STAR3_OFFICER);
+        selectRank(AbyssRankEnum.STAR2_OFFICER);
+        selectRank(AbyssRankEnum.STAR1_OFFICER);
+        updateToNoQuotaRank();
+        this.playerAGPEntries.clear();
+        this.playerAGpMaps.clear();
+    }
+
+    private void selectRank(AbyssRankEnum rank)
+    {
+        int quota = rank.getId() < 18 ? rank.getQuota() - AbyssRankEnum.getRankById(rank.getId() + 1).getQuota() : rank.getQuota();
+        for (int i = 0; i < quota; i++)
+        {
+            if (this.playerAGPEntries.isEmpty()) {
+              return;
+            }
+            Map.Entry<Integer, AGPoint> playerAGp = this.playerAGPEntries.get(0);
+            if (playerAGp == null) {
+                return;
+            }
+
+            int playerId = playerAGp.getKey();
+            int agp = playerAGp.getValue().getGP();
+            if (agp < rank.getGPRequired()) {
+                return;
+            }
+            this.playerAGPEntries.remove(0);
+            updateRankTo(rank, playerId);
+        }
+    }
+
+    private void updateToNoQuotaRank()
+    {
+        for (Map.Entry<Integer, AGPoint> playerAGPEntry : this.playerAGPEntries)
+        {
+           AbyssRankEnum rank = AbyssRankEnum.getRankForAGp(playerAGPEntry.getValue().getAP(), 0);
+           updateRankTo(rank, playerAGPEntry.getKey());
+        }
+    }
+
+    protected void updateRankTo(AbyssRankEnum newRank, int playerId)
+    {
+        Player onlinePlayer = World.getInstance().findPlayer(playerId);
+        if (onlinePlayer != null)
+        {
+            AbyssRank abyssRank = onlinePlayer.getAbyssRank();
+            AbyssRankEnum currentRank = abyssRank.getRank();
+            if (currentRank != newRank)
+            {
+                abyssRank.setRank(newRank);
+                AbyssPointsService.checkRankChanged(onlinePlayer, currentRank, newRank);
+            }
+        } else {
+            DAOManager.getDAO(AbyssRankDAO.class).updateAbyssRank(playerId, newRank);
+        }
+   }
+
+	private static class SingletonHolder {
+
+		protected static final AbyssRankUpdateService instance = new AbyssRankUpdateService();
+	}
+
+    private static class PlayerGpComparator<K, V extends Comparable<V>> implements Comparator<Map.Entry<K, AGPoint>> {
+
+        @Override
+        public int compare(Map.Entry<K, AGPoint> o1, Map.Entry<K, AGPoint> o2)
+        {
+          return -o1.getValue().getGP().compareTo(o2.getValue().getGP());
+        }
+    }
+
+}
Index: AbyssService.java
===================================================================
--- AbyssService.java	(nonexistent)
+++ AbyssService.java	(working copy)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.services.abyss;
+
+import com.aionemu.gameserver.model.DescriptionId;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.network.aion.serverpackets.SM_SYSTEM_MESSAGE;
+import com.aionemu.gameserver.utils.PacketSendUtility;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+import com.aionemu.gameserver.world.World;
+import com.aionemu.gameserver.world.knownlist.Visitor;
+
+/**
+ * @author ATracer
+ */
+public class AbyssService {
+
+	private static final int[] abyssMapList = {210050000, 220070000, 400010000, 600010000, 600020000, 600030000, 600040000, 600050000, 600060000,600090000, 600100000};
+
+	/**
+	 * @param player
+	 */
+	public static final boolean isOnPvpMap(Player player) {
+		for (int i : abyssMapList) {
+			if (i == player.getWorldId())
+				return true;
+		}
+		return false;
+	}
+
+	/**
+	 * @param victim
+	 */
+	public static final void rankedKillAnnounce(final Player victim) {
+
+		World.getInstance().doOnAllPlayers(new Visitor<Player>() {
+			@Override
+			public void visit(Player p) {
+				if (p != victim && victim.getWorldType() == p.getWorldType() && !p.isInInstance()) {
+					PacketSendUtility.sendPacket(p, SM_SYSTEM_MESSAGE.STR_ABYSS_ORDER_RANKER_DIE(victim, AbyssRankEnum.getRankDescriptionId(victim)));
+				}
+			}
+		});
+	}
+
+	public static final void rankerSkillAnnounce(final Player player, final int nameId) {
+		World.getInstance().doOnAllPlayers(new Visitor<Player>() {
+			@Override
+			public void visit(Player p) {
+				if (p != player && player.getWorldType() == p.getWorldType() && !p.isInInstance()) {
+					PacketSendUtility.sendPacket(p, SM_SYSTEM_MESSAGE.STR_SKILL_ABYSS_SKILL_IS_FIRED(player, new DescriptionId(nameId)));
+				}
+			}
+		});
+	}
+}
Index: AbyssSkillService.java
===================================================================
--- AbyssSkillService.java	(nonexistent)
+++ AbyssSkillService.java	(working copy)
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.services.abyss;
+
+import org.slf4j.LoggerFactory;
+
+import com.aionemu.gameserver.model.Race;
+import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
+import com.aionemu.gameserver.model.gameobjects.player.Player;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+
+/**
+ * @author ATracer
+ */
+public class AbyssSkillService {
+
+	/**
+	 * @param player
+	 */
+	public static final void updateSkills(Player player) {
+		AbyssRank abyssRank = player.getAbyssRank();
+		if (abyssRank == null) {
+			return;
+		}
+		AbyssRankEnum rankEnum = abyssRank.getRank();
+		// remove all abyss skills first
+		for (AbyssSkills abyssSkill : AbyssSkills.values()) {
+			if (abyssSkill.getRace() == player.getRace()) {
+				for (int skillId : abyssSkill.getSkills()) {
+					player.getSkillList().removeSkill(skillId);
+				}
+			}
+		}
+		// add new skills
+		if (abyssRank.getRank().getId() >= AbyssRankEnum.STAR5_OFFICER.getId()) {
+			for (int skillId : AbyssSkills.getSkills(player.getRace(), rankEnum)) {
+				player.getSkillList().addAbyssSkill(player, skillId, 1);
+			}
+		}
+	}
+
+	/**
+	 * @param player
+	 */
+	public static final void onEnterWorld(Player player) {
+		updateSkills(player);
+	}
+}
+
+enum AbyssSkills {
+	SUPREME_COMMANDER(Race.ELYOS, AbyssRankEnum.SUPREME_COMMANDER, 11889, 11898, 11900, 11903, 11904, 11905, 11906),
+	COMMANDER(Race.ELYOS, AbyssRankEnum.COMMANDER, 11888, 11898, 11900, 11903, 11904),
+	GREAT_GENERAL(Race.ELYOS, AbyssRankEnum.GREAT_GENERAL, 11887, 11897, 11899, 11903),
+	GENERAL(Race.ELYOS, AbyssRankEnum.GENERAL, 11886, 11896, 11899),
+	STAR5_OFFICER(Race.ELYOS, AbyssRankEnum.STAR5_OFFICER, 11885, 11895),
+	SUPREME_COMMANDER_A(Race.ASMODIANS, AbyssRankEnum.SUPREME_COMMANDER, 11894, 11898, 11902, 11903, 11904, 11905, 11906),
+	COMMANDER_A(Race.ASMODIANS, AbyssRankEnum.COMMANDER, 11893, 11898, 11902, 11903, 11904),
+	GREAT_GENERAL_A(Race.ASMODIANS, AbyssRankEnum.GREAT_GENERAL, 11892, 11897, 11901, 11903),
+	GENERAL_A(Race.ASMODIANS, AbyssRankEnum.GENERAL, 11891, 11896, 11901),
+	STAR5_OFFICER_A(Race.ASMODIANS, AbyssRankEnum.STAR5_OFFICER, 11890, 11895);
+
+	private int[] skills;
+	private AbyssRankEnum rankenum;
+	private Race race;
+
+	private AbyssSkills(Race race, AbyssRankEnum rankEnum, int... skills) {
+		this.race = race;
+		this.rankenum = rankEnum;
+		this.skills = skills;
+	}
+
+	public Race getRace() {
+		return race;
+	}
+
+	public int[] getSkills() {
+		return skills;
+	}
+
+	public static int[] getSkills(Race race, AbyssRankEnum rank) {
+		for (AbyssSkills aSkills : values()) {
+			if (aSkills.race == race && aSkills.rankenum == rank) {
+				return aSkills.skills;
+			}
+		}
+		LoggerFactory.getLogger(AbyssSkills.class).warn("No abyss skills for: " + race + " " + rank);
+		return new int[0];
+	}
+}
Index: AGPoint.java
===================================================================
--- AGPoint.java	(nonexistent)
+++ AGPoint.java	(working copy)
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2015, Aion Engine (dev.aionengine.com)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of Aion Engine nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package com.aionemu.gameserver.services.abyss;
+/**
+ * @author Magenik,hckd05
+ */
+
+public class AGPoint
+{
+    private Integer ap;
+    private Integer gp;
+
+    public AGPoint(int ap, int gp)
+    {
+        this.ap = Integer.valueOf(ap);
+        this.gp = Integer.valueOf(gp);
+    }
+
+    public Integer getAP()
+/* 15:   */   {
+/* 16:33 */     return this.ap;
+/* 17:   */   }
+
+    public Integer getGP()
+/* 20:   */   {
+/* 21:37 */     return this.gp;
+/* 22:   */   }
+}
Index: SM_ABYSS_RANK.java
===================================================================
--- SM_ABYSS_RANK.java	(nonexistent)
+++ SM_ABYSS_RANK.java	(working copy)
@@ -0,0 +1,79 @@
+/**
+ * This file is part of Aion-Lightning <aion-lightning.org>.
+ *
+ *  Aion-Lightning is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  Aion-Lightning is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details. *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Aion-Lightning.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ * Credits goes to all Open Source Core Developer Groups listed below
+ * Please do not change here something, ragarding the developer credits, except the "developed by XXXX".
+ * Even if you edit a lot of files in this source, you still have no rights to call it as "your Core".
+ * Everybody knows that this Emulator Core was developed by Aion Lightning 
+
+ * @-Aion-Lightning
+ * @Goong_ADM
+ */
+
+package com.aionemu.gameserver.network.aion.serverpackets;
+
+import com.aionemu.gameserver.model.gameobjects.player.AbyssRank;
+import com.aionemu.gameserver.network.PacketLoggerService;
+import com.aionemu.gameserver.network.aion.AionConnection;
+import com.aionemu.gameserver.network.aion.AionServerPacket;
+import com.aionemu.gameserver.utils.stats.AbyssRankEnum;
+
+/**
+ * @author Nemiroff Date: 25.01.2010
+ */
+public class SM_ABYSS_RANK extends AionServerPacket {
+
+    private AbyssRank rank;
+    private int currentRankId;
+
+    public SM_ABYSS_RANK(AbyssRank rank) {
+        this.rank = rank;
+        this.currentRankId = rank.getRank().getId();
+    }
+
+    @Override
+    protected void writeImpl(AionConnection con) {
+        writeQ(rank.getAp()); // curAP
+        writeD(rank.getGp()); // curGP
+        writeD(currentRankId); // curRank
+        writeD(rank.getTopRanking()); // curRating
+
+        int nextRankId = currentRankId < AbyssRankEnum.values().length ? currentRankId + 1 : currentRankId;
+		if (currentRankId >= 1 && currentRankId < 9)
+			writeD(100 * rank.getAp() / AbyssRankEnum.getRankById(nextRankId).getAPRequired()); // exp %
+		else if (currentRankId >= 9)
+			writeD(100 * rank.getGp() / AbyssRankEnum.getRankById(nextRankId).getGPRequired()); // exp %
+
+        writeD(rank.getAllKill()); // allKill
+        writeD(rank.getMaxRank()); // maxRank
+
+        writeD(rank.getDailyKill()); // dayKill
+        writeQ(rank.getDailyAP()); // dayAP
+        writeD(rank.getDailyGP()); // dayGP
+
+        writeD(rank.getWeeklyKill()); // weekKill
+        writeQ(rank.getWeeklyAP()); // weekAP
+        writeD(rank.getWeeklyGP()); // weekGP
+
+        writeD(rank.getLastKill()); // laterKill
+        writeQ(rank.getLastAP()); // laterAP
+        writeD(rank.getLastGP()); // laterGP
+
+        writeC(0x00); // unk
+    }
+}
